# BIP39
![NPM Version](https://img.shields.io/npm/v/%40iacobus%2Fbip39) ![NPM License](https://img.shields.io/npm/l/%40iacobus%2Fbip39) ![NPM Unpacked Size](https://img.shields.io/npm/unpacked-size/%40iacobus%2Fbip39)

> An extended implementation of BIP39.

This library supports an extended implementation of the [Bitcoin Improvement Proposal 39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki), *Mnemonic code for generating deterministic keys*. **TypeScript**, **ESM**, and **CommonJS** compatible. To get started, install the library:
```bash
# Deno
deno add jsr:@iacobus/bip39

# Node.js
npm install @iacobus/bip39
```
---

**Diversions from the proposal:** This library diverges from the guidelines BIP39 established in a few ways, primarily in regards to entropy handling and mnemonic length.  While mnemonic phrases in full compliance with the proposal can be generated using `bip39.core`, using `bip39.ext` supports generating phrases that fall outside the scope of the proposal.
 - **Entropy Encoding:** The proposal states that entropy must be a multiple of 32 bits, allowing an initial entropy length (ENT) between 128 and 256 bits. In this library, these requirements are relaxed, only requiring entropy to be a multiple of 11, with an expected length between 11 and 506 bits. Relaxing these requirements for `bip39.ext` allow for a greater range of mnemonic phrase lengths to be generated[^1].
- **Lack of Checksum:** The proposal states a checksum is generated by taking the first few bits of the SHA-256 hash of the entropy, and appending it to the end[^2]. For `bip39.ext.toMnemonic`, the decision was made to omit an internal checksum function, instead delegating the task to the user of the library so that raw entropy and entropy with a checksum can be processed equally (a checksum can be obtained for non-compliant entropy using `bip39.ent.checksum`).
- **Mnemonic Length:** As the proposal permits entropy between 128 and 256 bits, with a checksum of length `ENT / 32` appended, this makes for a range of 132 to 264 bits permissible for use in mnemonic generation. Adding the requirement that entropy be a multiple of 32 bits, this allows for mnemonic lengths based on multiples of 32 bits between 12 and 24 words (most commonly 12, 18, and 24). With the adjusted requirements in this library, mnemonics based on entropy of any multiple of 11 between 11 bits and 506 bits are possible with `bip39.ext.toMnemonic`, meaning any mnemonic length between 1 and 46 can be generated.

[^1]: *The minimum entropy length of 11 bits is necessary to obtain at least one word, as no word from any wordlist can be obtained with less than 11 bits. The maximum entropy length of 512 bits is necessary to avoid exceeding 512 bits in length, with 506 being the highest multiple of 11 below 512.*
[^2]: *To create a checksum, the first `ENT / 32` bits of the SHA-256 hash of the entropy is taken (e.g.. 128 / 32 = 4). These bits becomes the checksum, and are appended to the end of the initial entropy.*

As a note, this library only provides wordlists, functions for mnemonic generation and validation, checksum generation and verification, and mnemonic to entropy conversions. Since no internal entropy generator is present, all entropy must be obtained externally. Lastly, this library denotes a difference between initial entropy (`ent`), which is assumed to have no checksum applied, and `entropy`, which is assumed to include a checksum. The initial entropy `ent` should not be confused with the initial entropy length `ENT`.

# Usage
TypeScript/ESM Import:
```ts
import { bip39 } from "@iacobus/bip39";
```

CommonJS Require:
```js
const { bip39 } = require("@iacobus/bip39");
```

For demonstration purposes, methods and their parameters with types will be displayed in TypeScript, and the example use of the library will be displayed in ESM.

## Wordlists
Currently, wordlists from BIP39 that use the Latin alphabet are included: **Czech**, **English**, **French**, **Italian**, **Portuguese**, and **Spanish**. The non-Latin wordlists for Japanese, Korean, Chinese (Simplified), and Chinese (Traditional) are not included. Each wordlist can be imported as a property of `bip39.wordlist`.
```js
import { bip39 } from "@iacobus/bip39";

// English wordlist
const english = bip39.wordlist.english;

// Czech wordlist
const czech = bip39.wordlist.czech;

```

## toMnemonic
Mnemonic phrases can be obtained from entropy based on a provided wordlist, using the `toMnemonic` method of either the `bip39.core` or `bip39.ext`.

### bip39.core.toMnemonic
The `toMnemonic` method of `bip39.core` generates mnemonic phrases in compliance with BIP39.
```ts
bip39.core.toMnemonic(wordlist: string[], ent: string): string {};
```
This expects a `wordlist` parameter (e.g.. the English wordlist), and an `ent` parameter for initial entropy (entropy without a checksum). The initial entropy must be between 128 and 256 bits in length, and be divisible by 32. Creating and appending a checksum based on the initial entropy is handled internally, along with internal validation before returning the mnemonic.

*Example use:*
```js
import { bip39 } from "@iacobus/bip39";

const wordlist = bip39.wordlist.english;

const entropy = "01000010011011110110010101101001011011100110011100100000010000010011001100110010001100010010000001001101010000010101100000100001";

const mnemonic = bip39.core.toMnemonic(wordlist, entropy);
console.log(mnemonic);


// Sample Output:
// draw kite fog system improve calm smoke economy cake head figure drastic

```

### bip39.ext.toMnemonic
The `toMnemonic` method of `bip39.ext` generates mnemonic phrases non-compliant with BIP39.
```ts
bip39.ext.toMnemonic(wordlist: string[], entropy: string): string {};
```
This expects a `wordlist` parameter, and `entropy` parameter. The entropy must be between 11 and 506 bits in length, and divisible by 11. Since this extension of `toMnemonic` is non-compliant with BIP39, a wider range of mnemonic lengths than ordinarily permitted can be generated. There is no internal handling for a checksum, and there is no internal validation before the mnemonic is returned.

*Example use, with a mnemonic length of 17 (no checksum):*
```js
import { bip39 } from "@iacobus/bip39";

const wordlist = bip39.wordlist.english;

const entropy = "0101100101101111011101010010000001101010011101010111001101110100001000000110110001101111011100110111010000100000011101000110100001100101001000000110011101100001011011010110010100100001000";

const mnemonic = bip39.ext.toMnemonic(wordlist, entropy);
console.log(mnemonic);

// Sample Output:
// floor knife elite stay fire ring like mistake inflict patient brown speak faith crisp mad protect canal

```

## validate
Mnemonic phrases can be validated  based on a provided wordlist (and checksum length for the extended version), using the `validate` method of either `bip39.core` or `bip39.ext`.

### bip39.core.validate
The `validate` method of `bip39.core` checks the validity of a mnemonic phrase, based on a provided wordlist, for mnemonic phrases generated in compliance with BIP39.
```ts
bip39.core.validate(wordlist: string[], mnemonic: string): boolean {};
```
This expects a `wordlist` parameter, and a `mnemonic` parameter that must contain a compliant mnemonic phrase. This will check the validity of the provided mnemonic phrase, and then return a true or false value, where true means the phrase has passed validation, and false means the validation has failed.

*Example use:*
```js
import { bip39 } from "@iacobus/bip39";

const wordlist = bip39.wordlist.english;

const mnemonic = "draw kite fog system improve calm smoke economy cake head figure drastic";

const valid = bip39.core.validate(wordlist, mnemonic);
console.log(valid);

// Sample Output:
// true
```

### bip39.ext.validate
The validate method of bip39.ext checks the validity of a mnemonic phrase, based on a provided wordlist, for mnemonic phrases generated outside of compliance of BIP39.
```ts
bip39.ext.validate(wordlist: string[], mnemonic: string, checksumLength: number): boolean {};
```
This expects a `wordlist` parameter, a `mnemonic` parameter that must contain a mnemonic phrase, and a `checksumLength` parameter that is expected to be a number equal to the length (in bits) of the checksum. This will check the validity of the provided mnemonic phrase, and then return a true or false value, where true means the phrase has passed validation, and false means the validation has failed.

*Example use, with a mnemonic length of 14 and a 5 bit checksum:*
```js
import { bip39 } from "@iacobus/bip39";

const wordlist = bip39.wordlist.english;

const mnemonic = "embody clock brand tattoo afford crawl random mistake jaguar across bubble suspect black above";

const valid = bip39.ext.validate(wordlist, mnemonic, 5);
console.log(valid);

// Sample Output:
// true

```

## bip39.ent
Methods for converting mnemonics to entropy, entropy data conversions, obtaining a checksum, and verifying a checksum, are available under `bip39.ent` as `fromMnemonic`, `checksum`, and `verify`. These are not specific to either compliance or non-compliance with BIP39, and therefore work for both cases.

### Converting a Mnemonic to Entropy
Entropy (bits) can be obtained from a mnemonic phrase, based on a provided wordlist, using the `fromMnemonic` method of `bip39.ent`.
```ts
bip39.ent.fromMnemonic(wordlist: string[], mnemonic: string): string {};
```
This expects a `wordlist` parameter, and a `mnemonic` parameter that must contain a mnemonic phrase. This will convert the words of the mnemonic back to the entropy used to generate the phrase, including any checksum if present, returning the entropy (bits) in the output.

*Example use:*
```js
import { bip39 } from "@iacobus/bip39";

const wordlist = bip39.wordlist.english;

const mnemonic = "draw kite fog system improve calm smoke economy cake head figure drastic";

const entropy = bip39.ent.fromMnemonic(wordlist, mnemonic);
console.log(entropy);

// Sample Output:
// 010000100110111101100101011010010110111001100111001000000100000100110011001100100011000100100000010011010100000101011000001000010010

```

### Converting Entropy Data Types
The `ent` parameter which appears multiple times across this library expects initial entropy be provided as binary strings (bits). As entropy sources may provide entropy in various data types, functions are provided to convert from these different data types to the expected binary strings. The binary strings resulting from these conversions may be subject to further processing (e.g.. truncation before use in checksum generation) before use as initial entropy. The supported data types are **String**, **Buffer**, **Uint8Array**, and **Hexadecimal**.
```ts
// String
bip39.ent.(str: string): string {};

// Buffer
bip39.ent.fromBuffer(buf: Buffer): string {};

// Uint8Array
bip39.ent.fromUint8Array(uint8Array: Uint8Array): string {};

// Hexadecimal
bip39.ent.fromHex(hex: string): string {};

```
These methods each accept their respective data type as input, converting to and returning a binary string.

*Example use, converting from a Buffer:*
```js
import { bip39 } from "@iacobus/bip39";

// Obtain a binary string from a Buffer
const buf = Buffer.from('Greetings Human', 'utf8');
console.log("Buffer:", buf);

const ent = bip39.ent.fromBuffer(buf);
console.log("Binary String:", ent);

// Sample Output:
// Buffer: <Buffer 47 72 65 65 74 69 6e 67 73 20 48 75 6d 61 6e>
// Binary String: 010001110111001001100101011001010111010001101001011011100110011101110011001000000100100001110101011011010110000101101110

```

### Obtaining a Checksum
A checksum can be obtained and appended to initial entropy using the `checksum` method of `bip39.ent`.
```ts
bip39.ent.checksum(ent: string, checksumLength: number): string {};
```
This expects an `ent` parameter for the initial entropy in bits, and a `checksumLength` parameter which expects the length of the checksum in bits as a number. A checksum of the specified `checksumLength` will be generated based on the provided initial entropy, and will return the entropy with checksum appended in the output.

*Example use, with a checksum length of 5:*
```js
import { bip39 } from "@iacobus/bip39";

const ent = "01001000011001010110110001101100011011110010000001000110011001010110110001101100011011110111011100100000010010000111010101101101011000010110111000000";
const entropy = bip39.ent.checksum(ent, 5);
console.log(entropy);

// Sample Output:
// 0100100001100101011011000110110001101111001000000100011001100101011011000110110001101111011101110010000001001000011101010110110101100001011011100000000100

```

### Verifying a Checksum
An entropy string containing a checksum can be verified using the `verify` method of `bip39.ent`.
```ts
bip39.ent.verify(entropy: string, checksumLength: number): boolean {};
```
This expects an `entropy` parameter, which must contain an entropy string containing a checksum, and a `checksumLength` parameter, which expects the length of the checksum in bits as a number. This will attempt to verify the checksum in the given entropy string based on the checksum length, and then return a true or false value, where true means the checksum has passed verification, and false means the verification failed.

*Example use:*
```js
import { bip39 } from "@iacobus/bip39";

const entropy = "0100100001100101011011000110110001101111001000000100011001100101011011000110110001101111011101110010000001001000011101010110110101100001011011100000000100";

const verified = bip39.ent.verify(entropy, 5);
console.log(verified);

// Sample Output:
// true

```
